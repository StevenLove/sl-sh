;; This is a config file for people named price, you would put it in ~/.config/slsh/slshrc to use it.

(ns-import 'shell)
(ns-import 'iterator)
(ns-import 'struct)


(def slshrc-timer ((timer) :init "slshrc" #t))

(def slshrc-total-timer ((timer) :init "slshrc" nil))


;; gpwclark TODOs
;; - put in docs about how you call doc on the cmd line all the time with custom stuff!!
;; - rewrite bash-completions so we don't have gpl in here?
;; - tab cmpletion for paths with ~ does not work when bash-completions is on
;; - chain completion hooks
;; - track bkrd processes in PS1? could be helpful?
;; - string interpolation sytnax includes $my-var and ${my-var} as well as $(println foo)
;; - use this or make it: https://hg.stevelosh.com/t/
;; - maybe list bkrd processes as well in prompt.
;; - once implemented replace use of find with sl-sh builtins. to check for elapsed time
;; - maybe a version of this that strips out all non first/last char consononants

(def default-namespaces (collect-vec (filter (fn (x) (not (= x "user"))) (ns-list))))

;; bash-completions.lisp is located in `contrib/gpwclark`
;;(load "~/.config/sl-sh/bash-completions.lisp")

;; shell helpers {{{

    (defmacro rsynccp
        "sane defaults for treating rsync like copy.
        Section: user-shell"
        (src target)
        `$(rsync -av ,src ,target --progress --inplace --no-compress))

	(defn dsh
		"With no arguments: alias for du ./* -sh
		With any args: provides size of each provided argument
		Section: user-shell"
		(&rest paths)
		(if (= 0 (length paths))
			$(du ./* -sh | sort -h)
			(for path in paths $(du path -sh | sort -h))))

	(defn pgz
		"Parallelized gzip.
		cores:
			use lscpu to determine # of cores on box
		compression-ratio:
			- 1 fastest speed, worst compression
			- 9 slowest speed, most compression
			- default is 6

		Section: user-shell"
		(target-name cores compression-ratio &rest dirs)
			$(tar cf - $((str-cat-list " " dirs)) |
				pigz  -p  $cores  " -" $compression-ratio |
				$target-name))
	(defn dpgz
	"Parallelized un gzip.
	cores:
		use lscpu to determine # of cores on box
	Section: user-shell"
			(target-name cores)
				$(pigz --keep --decompress --processes $cores $target-name))

	(defn fullfp
	"Give me a relative filepath and I'll give you an absolute filepath!
	Section: user-shell"
		(filepath)
		$(find $PWD -name filepath))

	(defn mrf
		"most recent files. return ordered list (oldest -> newest) of files in current working dir
		Section: user-shell"
		()
		(str-split " " (str-trim (str $(/sbin/ls -at | tr "\n" " " | tr -s "[[:blank:]]")))))

	(defn lftail
		"Provide string to filter results of ls. Newest file that contains
		that string is then \"tail -f\"'d

		Section: user-shell"
		(str-to-tail-f) (do
		(var matching-list (filter (fn (x) (and (fs-file? x) (str-contains str-to-tail-f x))) (mrf)))
		(var tail-target (first (collect matching-list)))
		(tail -f tail-target)))

	(defn cdt
	"cd into the directory with the most recent timestamp
	Section: user-shell
	"
		(&rest args)
			(when (> (length args) 1 )
				(err "cdt supports zero or one arguments."))
			(var most-recent-dir
				(first (collect-vec (filter (fn (x) (and (if (= 1 (length args)) (str-contains (first args) (str x)) #t) (fs-dir? x) (not (= ".." x)) (not (= "." x)))) (mrf)))))
			(eval `(cd ,most-recent-dir)))


;; stdin to clipboard
(defmacro sc
	"pipe things into this and they'll be in your clipboard.
	Section: user-shell
	"
	()
	`$(xclip -selection c))

(defmacro this
	"
	put my pwd in my clipboard
	Section: user-shell
	"
	()
	`$(echo -n $((str-trim (str $(pwd)))) | sc))

(defn zh
	"
	fuzzy zsh history search
	Section: user-shell
	"
	()
	(do
		(var raw-zsh-str (str $(cat ~/.zsh_history | fzf-tmux)))
		(eval (str "(loose-symbols (" (str-cat-list ";" (rest (str-split ";" raw-zsh-str))) "))"))))

(defn stripcolor
	"remove all color codes from any strings
	Section: user-shell"
	(&rest args)
	(if (< (length args) 2)
		$(perl -pe "s/\e\[?.*?[\@-~]//g']" $((nth 0 ars)))
		(err "Only accepts 0 or 1 arguments")))

;; all find . -iname &rest
(defn ifind
	"pass in a string. list all files in vim whose filenames contain that string.
	Section: user-shell"
	(&rest args)
	(if (< (length args) 2)
		(| $(find $PWD -iname $((str (nth 0 args)))))
		(err "Only accepts 0 or 1 arguments")))

;;results feed into vim
(defn vimifind
	"pass a string. open all files in vim whose filenames contain that string.
	Section: user-shell"
	(&rest args)
	(if (< (length args) 2)
		(let
			((vimargs (str-split
				" "
				(str-trim (str (| $(find $PWD -iname $((nth 0 args))) $(tr "\n" " ")))))))
			(do
				(eval `(syscall vim ,@vimargs))))
		(err "Only accepts 0 or 1 arguments")))

(slshrc-timer :pr-next "shell helpers")
;; }}}

;; java helpers {{{

;;gradle build
(defn g
        "gradle alias that writes all output to \"last_build.log\" and triggers a
        notification letting you know if the command succeeded or failed.

        Section: java"
        (&rest args)
        (let ((log-out-file "last_build.log")
              (gradle-proc)
              (gradle-ret-code)
              (log-out-txt)
              (proj-name)
              (pipe-procs))
                (set! pipe-procs
                  (pipe
                    (apply syscall "./gradlew" args)
                    (syscall 'tee log-out-file)))
                (set! gradle-proc (values-nth 1 pipe-procs))
                (set! gradle-ret-code (wait gradle-proc))
                (set! log-out-txt (str "Build log in " log-out-file "\n" $(cat $log-out-file | tail -n 2 | head -n 2)))
                (set! proj-name $(basename $PWD))
                (if (= 0 gradle-ret-code)
                        (nss-pass (str "PASS! - " proj-name) log-out-txt)
                        (nss-fail (str "FAIL! - " proj-name) log-out-txt))
                (= 0 gradle-ret-code)))

(defmacro javad
	"Start the jvm in debug mode, will hang until a debugger connects to jvm on port 5005
	Section: java"
	(&rest args)
		`$(java "-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005" ,@args))
(slshrc-timer :pr-next "java helpers")
;; }}}


;; custom env settings {{{

;; obviously...
	(export 'EDITOR "vim")

;; use vi keybindings on cli
	(hash-set! *repl-settings* :keybindings :vi)
	(hash-set! *repl-settings* :vi_esc_sequence '("jk" 200))
	(hash-set! *repl-settings* :vi-normal-prompt-prefix (str (bg-color-rgb 255 140 0)))
	(hash-set! *repl-settings* :vi-normal-prompt-suffix (str shell::*bg-default*))

;; syntax highlighting
	(syntax-on)

;; tweak token colors
	(set! tok-default-color shell::*fg-magenta*)
	(set! tok-sys-command-color shell::*fg-green*)
	(set! tok-string-color (fg-color-rgb 255 128 0))

;; you never know
	(hash-set! *repl-settings* :max-history 10000)

(slshrc-timer :pr-next "custom env settings")
;; }}}


;; quality of shell life {{{

(alias dkc
"Typing out docker-compose takes forever.
Section: user-shell"
	(docker-compose))

(defn :q ()
       ":q makes sense as an exit alias
       Section: user-shell"
       (exit))

(alias ls
	"alias ls to a colorified version.
	Section: user-shell"
	(lsd))

;; betterer ls
(alias ll
	"ls -haltr shorcut
	Section: user-shell"
	(lsd -haltr))

;; Replace cd with a version that also runs ls after.
;; Macro to let un-expanded args go to root::cd.
(defmacro cd
	"(= 'cd (do (cd) (ls))) ;; life changing
	Section: user-shell"
	(&rest args) (do
		(if (= (length args) 0)
			(and (root::cd) (ls .))
			(if (= (length args) 1)
				(and (root::cd (first args)) $(ls .))
				(err "I take zero or one argument.")))
		nil))
	;; use register-alias to have better syntax highlighting for cd.
	(register-alias 'cd)
(slshrc-timer :pr-next "quality of shell life")
;; }}}

;; quality of life {{{
    (defn cathead (n file)
          $(cat $file | head -n $n))

    (defn cattail (n file)
          $(cat $file | tail -n $n))

    (defn catail (n file)
          $(cat $file | tail -n $n))

	(defn spl
	"Give it a spelling of a word, it will tell you what words are spelled like it.
	Section: user-shell
	"
	(word)
		(println (str (| (echo (str word)) $(aspell -a)))))

(defn weather
	"print weather in terminal
	Section: user-shell"
		()
		$(curl "wttr.in"))
;; }}}

;; notification helpers {{{

(defmacro nss (title msg icon)
	`$(notify-send -t 0 ,title ,msg -i ,icon))

(defn persist-nss
	"provide persistent notification via notify-send and libnotify
	Section: notify"
	(title msg)
	(nss title msg "system-software-update"))

(defn nss-pass
	"provide persistent success notification via notify-send and libnotify
	Section: notify"
	(title msg)
	(nss title msg "face-wink"))

(defn nss-fail
	"provide persistent failure notification via notify-send and libnotify
	Section: notify"
	(title msg)
	(nss title msg "process-stop"))

(defn pnss
	"provide fun persistent notification via notify-send and libnotify
	Section: notify"
	(title)
	(persist-nss title (str (fortune))))

;;tell me about it!
(defn tmai
	"provide persistent notification of previous commands return code via notify-send and libnotify
	Section: notify"
	()
	(do
		(var last-ret-val *last-status*)
		(pnss (str "Last program exit status: " last-ret-val  "."))
		last-ret-val))

;; }}}

;; tmux aliases {{{

(defn tmuxls
	"list tmux sessions
	Section: tmux "
	()
	$(tmux list-sessions))

(defn tmuxnew
	"new named tmux session
	Section: tmux"
	()
	$(tmux new -s))

(defn tmuxkill
	"kill all tmux sessions
	Section: tmux"
	()
	$(tmux kill-session -t))

(defn tmuxopen
	"open existing named tmux session or create named session if it does not exist
	Section: tmux"
	(&rest args)
		(if (= (length args) 1)
			(do
				(var tmux-ret-code $(tmux a -t $((first args))))
				(if (= 0 tmux-ret-code)
					0
					$(tmuxnew $((first args)))))
			(err "Takes one argument, name of tmux session to create.")))

;; }}}

;; time helpers {{{

;; epoch in milliseconds
(defn epochms
	"epoch in milliseconds
	Section: time"
	()
	(epoch))

(defn datest
	"human readable eastern time zone
	Section: time"
	()
	(let-env ((TZ ":America/New_York"))
	 $(date)))

(defn fromepoch
	"
	takes epoch IN SECONDS and converts to nice date time
	Section: time"
	(time)
	$(date -d $((str "@" time))))

(defn timestamp
	"simple timestamp for use with naming
	Section: time"
	()
	$(date +%Y%m%d_%H%M%S))

;; }}}


;; prompt {{{

(defn get_pwd
	"pwd but replaces home with ~
	Section: prompt"
	()
	(str-cat-list "/" (str-split "/" (str-replace (str-trim $PWD) $HOME "~"))))

(defn remove-vowels (target)
      (if (> (length target) 4)
        (let* ((vowels (list "a" "e" "i" "o" "u"))
             (first-char (str-nth 0 target))
             (mid-chars (str-sub 1 (- (length target) 2) target))
             (last-char (str-nth (- (length target) 1) target)))
        (str first-char (apply str (collect (filter (fn (y) (not (in? vowels (str y)))) mid-chars))) last-char))
        target))

(defn path-list-trunc
	"take a path string abbreviates it
	Section: prompt"
	(plist)
	(if (> (length plist) 1)
		(if (> (length (first plist)) 0)
			(vec-insert! (path-list-trunc (rest plist)) 0 (remove-vowels (first plist)))
			(path-list-trunc (rest plist)))
		plist))

(defn smaller-path
	"take a path string abbreviates it
	Section: prompt"
	(dir)
	(str-cat-list "/" (path-list-trunc (str-split "/" (str-replace (str-trim dir) $HOME "~")))))

(defn set-prompt-tail
	"used to grab return value of last command and put a non 0 error code in
	the prompt for greater visibility.
	Section: prompt"
	(last-status)
	(let* ((last-status-success (= 0 last-status))
		(prompt (if last-status-success
                      (str prompt-left prompt-cog prompt-right)
                      (str
                        shell::*fg-red*
                        "\u{03bb}\u{2e28}\u{2699}\u{2009}\u{2e29}\u{2009}\u{2192} "
                        shell::*fg-default*))))
      prompt))


(defn parse_git_branch
	"if in git repo, get the name of the branch
	Section: git"
	() (let ((branch))
	(err>null (set! branch (str $(git rev-parse --abbrev-ref HEAD))))
	(if (= branch "")
		(str "")
		(str "(" (str-trim branch) ")"))))

(defn get-build-type () (do
	(var build-type (nth 3 (str-split " " (version))))
	(if (= build-type "debug")
		(str " (" shell::*bg-red* build-type shell::*bg-default* ")")
		"")))

(def ascii-dec-lookup (make-hash (list (join #\  32) (join #\! 33) (join #\" 34) (join #\# 35) (join #\$ 36) (join #\% 37) (join #\& 38) (join #\' 39) (join #\( 40) (join #\) 41) (join #\* 42) (join #\+ 43) (join #\, 44) (join #\- 45) (join #\. 46) (join #\/ 47) (join #\0 48) (join #\1 49) (join #\2 50) (join #\3 51) (join #\4 52) (join #\5 53) (join #\6 54) (join #\7 55) (join #\8 56) (join #\9 57) (join #\: 58) (join #\; 59) (join #\< 60) (join #\= 61) (join #\> 62) (join #\? 63) (join #\@ 64) (join #\A 65) (join #\B 66) (join #\C 67) (join #\D 68) (join #\E 69) (join #\F 70) (join #\G 71) (join #\H 72) (join #\I 73) (join #\K 74) (join #\L 75) (join #\M 76) (join #\N 77) (join #\O 78) (join #\P 79) (join #\Q 80) (join #\R 81) (join #\S 82) (join #\T 83) (join #\U 84) (join #\V 85) (join #\W 86) (join #\X 87) (join #\Y 88) (join #\Z 90) (join #\[ 91) (join #\\ 92) (join #\] 93) (join #\^ 94) (join #\_ 95) (join #\` 96) (join #\a 97) (join #\b 98) (join #\c 99) (join #\d 100) (join #\e 101) (join #\f 102) (join #\g 103) (join #\h 104) (join #\i 105) (join #\j 106) (join #\k 107) (join #\l 108) (join #\m 109) (join #\n 110) (join #\o 111) (join #\p 112) (join #\q 113) (join #\r 114) (join #\s 115) (join #\t 116) (join #\u 117) (join #\v 118) (join #\w 119) (join #\x 120) (join #\y 121) (join #\z 122) (join #\{ 123) (join #\| 124) (join #\} 125) (join #\~ 126))))

(defn colorize-rand (string seed)
    (let* ((fg-color-vec (vec shell::*fg-default* shell::*fg-red*
                            shell::*fg-green* shell::*fg-yellow*
                            shell::*fg-blue* shell::*fg-magenta*
                            shell::*fg-cyan* shell::*fg-white*))
           (num (math::round (apply stats::mean (collect (map (fn (char) (hash-get ascii-dec-lookup char)) seed)))))
           (color (vec-nth
                    fg-color-vec
                    (% num
                        (length fg-color-vec)))))
        (str color
            string
            shell::*fg-default*)))

(def sl-sh-open-paren (colorize-rand "[" (str $HOST "1")))
(def sl-sh-title (colorize-rand "sl-sh" (str $HOST "4")))
(def sl-sh-close-paren (colorize-rand  "] " (str $HOST "1")))
(def open-paren (colorize-rand "{[ " (str $HOST "7")))
(def host-string (colorize-rand $HOST $HOST))
(def close-paren (colorize-rand " ]}" (str $HOST "7")))
(def prompt-left (colorize-rand "\u{03bb}\u{2e28}" (str $HOST "9")))
(def prompt-cog (colorize-rand "\u{2699}\u{2009}" (str $HOST "4")))
(def prompt-right (colorize-rand "\u{2e29}\u{2009}\u{2192} " (str $HOST "9")))

;; prompt ensures
;;	1. always a new line above prompt
;;	2. if pushd has been used displays in reverse order dirs to popd
;;	3. current path
;;	4. if in git dir display current branch
;;	5. cursor on near empty line
(defn __prompt ()
    (do
        (var token-str (str-trim *last-command*))
        ;; TODO you can feed read a default argument
        ;; avoid wrap in get-error
        (var ret (get-error (read-all token-str)))
        (when (and
                (= :ok (car ret))
                (> (length token-str) 0)
                (not (empty-seq? token-str)))
            (do
                (set! token-str (collect (reverse (cdr ret))))
                (if (= (first token-str) '\$la)
                  (export 'la \$la)
                  (export 'la (str (first token-str))))
                (when (> (length token-str) 1)
                  (if (= (nth 1 token-str) '\$2la)
                    (export '2la \$2la)
                    (export '2la (str (nth 1 token-str)))))
                (when (> (length token-str) 2)
                  (if (= (nth 2 token-str) '\$3la)
                    (export '3la \$3la)
                    (export '3la (str (nth 2 token-str)))))))
        (var last-status *last-status*)
        (str
            "\n"
            (if (> (length (get-dirs)) 0)
                (collect-str (map smaller-path (reverse (get-dirs))))
                "")
            "\n\r" sl-sh-open-paren sl-sh-title (get-build-type) sl-sh-close-paren open-paren  host-string close-paren ": " shell::*fg-magenta* (smaller-path (str-trim (get_pwd))) "/ " shell::*fg-default* (parse_git_branch) "\n"
            (set-prompt-tail last-status))))

(slshrc-timer :pr-next "prompt")
;; }}}

;; i'm fun {{{
(println "                                           ██╗")
(println "                                           ██║")
(println "                                           ██║")
(println "      ██████████████████████████████████╗  ██║")
(println "      ██╔═════════════════════════════██║  ██║")
(println "      ██║                             ██║  ██║")
(println "███████╗██╗      ███████╗██╗  ██╗     ██║  ██║")
(println "██╔════╝██║      ██╔════╝██║  ██║     ██║  ██║")
(println "███████╗██║█████╗███████╗███████║     ██║  ██║")
(println "╚════██║██║╚════╝╚════██║██╔══██║     ██║  ██║")
(println "███████║███████╗ ███████║██║  ██║     ██║  ██║")
(println "╚══════╝╚══════╝ ╚══════╝╚═╝  ╚═╝     ██║  ╚═╝")
(println " ██╗  ██║                             ██║")
(println " ██║  ██████████████████████████████████║")
(println " ██║  ╚═════════════════════════════════╝")
(println " ██║")
(println " ██║  ████████████████████████████████████████████╗")
(println " ██║  ╚═══════════════════════════════════════════╝")
(println " ██║")
(println " ╚═╝")

(println "		Hey, hey, hey. Don't be mean.")
(println "		We don't have to be mean because,")
(println "		remember, no matter where you go,")
(println "		there you are.")
(println (str "			- Buckaroo Banzai (" (str-trim $(cat ~/.local/share/sl-sh/history | grep -v "<ctx>" | wc -l)) ")"))
(intern-stats)

(slshrc-timer :pr-next "ps")
;; }}}

;; machine specific {{{

    (def custom-lisp-config (str "~/.config/sl-sh/" (str-trim (str $(cat /etc/hostname))) ".lisp"))
    (if (fs-exists? custom-lisp-config)
        ((fn (result)
            (if (= :ok (car result))
                (cdr result)
                (cdr result)))
             (get-error (load custom-lisp-config)))
        (println (str shell::*fg-red* "Failed loading sl-sh config at " custom-lisp-config shell::*fg-default*)))

(slshrc-timer :pr-next "machine-specific")
;; }}}


;; exec hook {{{

;; entrypoint for all 1 arg commands... used to make filepaths cd commands
;; to themselves.
(defn change-dir-if-arg-is-dir (cmd orig-cmd-ast)
	(let ((cmd-str (str cmd)))
		(if (fs-dir? cmd-str)
			(list root::cd cmd-str)
			orig-cmd-ast)))

;; if direcotry input, treat it as if it was prefixed by cd,
;; due to shell reader changes receive and return raw string,
;; do not return a list.
(defn __exec_hook (cmd-str)
    (if (fs-dir? cmd-str)
        (str "cd " cmd-str)
        cmd-str))

(slshrc-timer :pr-next "exec-hook")
;; }}}

;; user ns docs {{{


(def api-page-name "mydoc_api.md")
(def api-page (str "pages/mydoc/" api-page-name))
(shell::pushd "/home/price/development/slsh/docs")
(def docs-error-ret
    (get-error (when (or
        (nil? (fs-exists? api-page))
        (= api-page (str-trim (str $(find $api-page -type f -mmin "+1440"))))) (do
    (load "docstrings-to-md.lisp")
    (load "mk-docs.lisp")
    (load "docstruct.lisp")
    (defn filter-non-user-forms (sym-list namespaces) (do
        (if (empty-seq? namespaces)
            sym-list
              (recur
                  (collect-vec (filter (fn (x) (do
                                (not (in? (ns-symbols (sym (first namespaces))) x))))
                      sym-list))
              (rest namespaces)))))

    (defn filter-user-undocable-forms (sym-list)
        (var to-filter (list 'custom-lisp-config 'filter-non-user-forms 'filter-user-undocable-forms 'list-of-user-slsh-syms '*repl-settings* '__completion_hook 'default-namespaces 'tok-invalid-color 'tok-default-color 'tok-string-color 'endfix-on 'config-file 'token-str 'all-non-user-namespaces 'build-type 'user-syms 'the-ns 'last-status '*ns-exports* '__line_handler '__exec_hook '__prompt 'tok-slsh-fcn-color 'possible-completions 'all-user-slsh-syms 'all-docstrings 'colorize-rand 'colorize-rand-cache 'smaller-path 'parse_git_branch 'sl-sh-open-paren 'sl-sh-title 'sl-sh-close-paren 'open-paren 'host-string 'close-paren 'api-page 'api-page-name))
          (filter (fn (x) (not (in? to-filter x))) sym-list))

    ;; TODO ideally this would live in mk-docs.lisp
    ;; and :user would be an option as param of mkdocs::get-doc-list-for
    (defn list-of-user-slsh-syms () (do
        (var user-syms (list))
        (var all-non-user-namespaces (append-to! (list) default-namespaces (list "mkdocs" "docparse" "docmd")))
        (for a-ns in (filter
                        (fn (x) (not (in? all-non-user-namespaces x)))
                        (ns-list))
            (append-to! user-syms (ns-symbols (sym a-ns))))
        (var user-forms (filter-non-user-forms user-syms default-namespaces))
        (var partial-docable-user-forms (mkdocs::filter-undocable-forms user-forms))
        (var all-docable-user-forms (filter-user-undocable-forms partial-docable-user-forms))
        (collect-vec all-docable-user-forms)))

    (def all-user-slsh-syms (list-of-user-slsh-syms))
    (def get-doc-pair (fn (x) (let ((result (get-error (doc (sym x)))))
                                  (if (= :ok (car result))
                                    (do
                                      (list sym (car result))
                                      (def new-result (car result))
                                      new-result)
                                    (println "Error: sym doc fail: " (cdr result))))))
    ;; check the last modified time of api-page-name and only do this if
    ;; has not been done in some amount of time.
    (def docs-by-section (make-hash))
    (for doc-struct in (map docstruct::make-doc-struct all-user-slsh-syms)
          (let ((section-key (doc-struct :section-key)))
            (if (hash-haskey docs-by-section section-key)
                (append-to! (hash-get docs-by-section section-key) doc-struct)
            (hash-set! docs-by-section section-key (list doc-struct)))))
    (docmd::make-md-file-with-sections api-page docs-by-section)
    (println "Built docs!")))))
(shell::popd)
(if (not (= (car docs-error-ret) :ok))
    (println "Failed to build docs: " (cdr docs-error-ret)))
(undef api-page-name)
(undef api-page)
(undef docs-error-ret)
(slshrc-timer :pr-next "ns-docs")
;; }}}

;; cleanup symbols I might use {{{
(slshrc-timer :pr-next "end")
(slshrc-total-timer :pr-next "full load time")
;; }}
